name: Release on Version Change

on:
  push:
    branches: [main]
    paths:
      - 'apps/project-2359-rn/package.json'

jobs:
  check-version-and-release:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    outputs:
      version_changed: ${{ steps.version_check.outputs.changed }}
      new_version: ${{ steps.version_check.outputs.version }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.2.2 # v4.2.2
        with:
          fetch-depth: 2

      - name: Check if version changed
        id: version_check
        run: |
          # Get current version using jq with proper quoting
          CURRENT_VERSION=$(jq -r '.version // "0.0.0"' apps/project-2359-rn/package.json)
          
          # Validate version format (semantic versioning)
          if ! echo "$CURRENT_VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$'; then
            echo "Error: Invalid version format: $CURRENT_VERSION"
            exit 1
          fi
          
          # Get previous version - use a secure temporary directory
          TEMP_DIR=$(mktemp -d)
          trap "rm -rf $TEMP_DIR" EXIT
          
          git show HEAD~1:apps/project-2359-rn/package.json > "$TEMP_DIR/old_package.json" 2>/dev/null || echo '{"version":"0.0.0"}' > "$TEMP_DIR/old_package.json"
          PREVIOUS_VERSION=$(jq -r '.version // "0.0.0"' "$TEMP_DIR/old_package.json")
          
          echo "Current version: $CURRENT_VERSION"
          echo "Previous version: $PREVIOUS_VERSION"
          
          if [ "$CURRENT_VERSION" != "$PREVIOUS_VERSION" ]; then
            echo "Version changed from $PREVIOUS_VERSION to $CURRENT_VERSION"
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          else
            echo "Version unchanged"
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

  build-and-release:
    needs: check-version-and-release
    if: needs.check-version-and-release.outputs.version_changed == 'true'
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    env:
      APP_NAME: project-2359-rn
      VERSION: ${{ needs.check-version-and-release.outputs.new_version }}
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.2.2 # v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@v4.1.0 # v4.1.0
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/project-2359-rn/package-lock.json

      - name: Install dependencies
        working-directory: apps/project-2359-rn
        run: npm ci

      - name: Setup Expo CLI
        run: npm install -g expo-cli eas-cli

      - name: Setup EAS
        run: eas login --token ${{ secrets.EXPO_TOKEN }}

      - name: Extract changelog for this version
        id: changelog
        env:
          VERSION: ${{ env.VERSION }}
        run: |
          # Validate VERSION format again to prevent injection
          if ! echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$'; then
            echo "Error: Invalid version format for changelog extraction"
            exit 1
          fi
          
          # Use a secure temporary directory
          TEMP_DIR=$(mktemp -d)
          trap "rm -rf $TEMP_DIR" EXIT
          
          if [ -f CHANGELOG.md ]; then
            # Extract content between this version header and the next version header (or EOF)
            # Using awk with safe variable passing
            awk -v ver="$VERSION" '
              BEGIN { found=0; content="" }
              /^## v?[0-9]+\.[0-9]+\.[0-9]+/ {
                if (found) exit
                if (index($0, ver) > 0) found=1
                next
              }
              found { content = content $0 "\n" }
              END { print content }
            ' CHANGELOG.md > "$TEMP_DIR/changelog_content.txt"
            
            # Check if changelog was found
            if [ ! -s "$TEMP_DIR/changelog_content.txt" ]; then
              echo "No changelog entry found for version $VERSION" > "$TEMP_DIR/changelog_content.txt"
            fi
          else
            echo "No CHANGELOG.md file found" > "$TEMP_DIR/changelog_content.txt"
          fi
          
          # Copy to a known location that won't be cleaned up by trap
          cp "$TEMP_DIR/changelog_content.txt" /tmp/changelog_content.txt
          echo "changelog_file=/tmp/changelog_content.txt" >> $GITHUB_OUTPUT

      # ===============================
      # Android APK Build (Production)
      # ===============================
      - name: Build Android APK (Production)
        working-directory: apps/project-2359-rn
        run: eas build --platform android --profile production --non-interactive --local
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

      - name: Find and rename APK
        id: find_apk
        env:
          APP_NAME: ${{ env.APP_NAME }}
          VERSION: ${{ env.VERSION }}
        run: |
          # Validate VERSION format
          if ! echo "$VERSION" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$'; then
            echo "Error: Invalid version format"
            exit 1
          fi
          
          # Find APK only within the expected directory, not following symlinks
          APK_PATH=$(find apps/project-2359-rn -maxdepth 3 -name "*.apk" -type f ! -path "*/node_modules/*" | head -1)
          
          if [ -n "$APK_PATH" ] && [ -f "$APK_PATH" ]; then
            # Sanitize the filename
            SAFE_VERSION=$(echo "$VERSION" | tr -cd '0-9a-zA-Z.-')
            NEW_APK_PATH="apps/project-2359-rn/${APP_NAME}-v${SAFE_VERSION}.apk"
            
            mv "$APK_PATH" "$NEW_APK_PATH"
            echo "apk_path=$NEW_APK_PATH" >> $GITHUB_OUTPUT
          else
            echo "Error: No APK file found"
            exit 1
          fi

      # ===============================
      # Web Build & Deploy
      # ===============================
      - name: Build Web App
        working-directory: apps/project-2359-rn
        run: npx expo export --platform web --output-dir dist

      - name: Prepare deployment structure
        run: |
          mkdir -p deploy/react-native
          mkdir -p deploy/flutter
          mkdir -p deploy/react
          cp -r apps/project-2359-rn/dist/* deploy/react-native/
          # Create root index
          echo '<!DOCTYPE html><html><head><meta charset="utf-8"><title>Project 2359</title></head><body><h1>Project 2359</h1><ul><li><a href="/react-native">React Native App</a></li><li><a href="/flutter">Flutter App</a></li><li><a href="/react">React App</a></li></ul></body></html>' > deploy/index.html

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4.0.0 # v4.0.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./deploy
          destination_dir: .
          keep_files: true

      # ===============================
      # Create Official Release
      # ===============================
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2.2.0 # v2.2.0
        with:
          tag_name: v${{ env.VERSION }}
          name: "${{ env.APP_NAME }} v${{ env.VERSION }}"
          body_path: ${{ steps.changelog.outputs.changelog_file }}
          files: |
            ${{ steps.find_apk.outputs.apk_path }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
